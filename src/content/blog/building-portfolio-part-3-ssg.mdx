import ogImage from 'virtual:og-image?title=Static Site Generation Without the Framework&description=Auto-crawling SSG, route discovery from Vite manifests, and module preloading.&tags=SSG,Vite,Performance&type=blog&seriesPart=3&seriesTotalParts=9';

export const metadata = {
	slug: 'building-portfolio-part-3-ssg',
	title: 'Static Site Generation Without the Framework',
	description:
		'Auto-crawling SSG, route discovery from Vite manifests, and module preloading.',
	tags: ['SSG', 'Vite', 'Performance'],
	publishedAt: '2025-12-16T10:00:00.000Z',
	featuredImage: ogImage,
	draft: false,
	series: {
		id: 'building-portfolio',
		title: 'Building a Modern Portfolio Without a Meta-Framework',
		part: 3,
		totalParts: 9,
	},
};

_Part 3 of the "Building a Modern Portfolio Without a Meta-Framework" series_

---

The first time I saw someone explain SSG, they made it sound trivial: "just render your React app to HTML at build time." Three weeks later, I understood why Next.js exists.

Static Site Generation is conceptually simple. The implementation details are where it gets interesting.

## What SSG Actually Means

At its core, SSG is three steps:

1. **Build time**: Render each page to HTML
2. **Serve time**: Send static HTML files (fast, cacheable, cheap)
3. **Client time**: React "hydrates" the HTML, attaching event handlers

The user gets instant content (the HTML is already there), then the page becomes interactive once JavaScript loads. Best of both worlds—if you can make it work.

## The Build Pipeline

Before diving into the SSG script itself, here's how Vite builds everything:

```typescript
// vite.config.ts
environments: {
  client: {
    build: { outDir: 'dist/client', manifest: true }
  },
  ssr: {
    build: { outDir: 'dist/server', ssr: true }
  },
  ssg: {
    build: {
      outDir: 'dist/ssg',
      ssr: true,
      rollupOptions: {
        input: resolve(__dirname, 'src/entry-server.tsx')
      }
    }
  }
},
builder: {
  async buildApp(builder) {
    await Promise.all([
      builder.build(builder.environments.client),
      builder.build(builder.environments.ssr),
      builder.build(builder.environments.ssg),
    ]);
    await ssg(); // Our custom SSG script
  }
}
```

Three parallel builds:

- **client**: The browser bundle with code splitting
- **ssr**: The Cloudflare Worker for API routes
- **ssg**: A Node-compatible build of the React app for pre-rendering

The `manifest: true` on the client build is important—it generates a JSON file mapping source files to output chunks. We'll use that for module preloading.

Vite is doing a lot of the heavy lifting here: bundling, code splitting, tree shaking, and compiling JSX/TypeScript. The SSG script just needs to render routes and write HTML files. Thanks to Vite's new [environment api](https://vite.dev/guide/api-environment), we can orchestrate everything cleanly.

## The Server Entry

The SSG script needs a way to render React to HTML. That's the server entry:

```tsx
// src/entry-server.tsx
import { renderToReadableStream } from 'react-dom/server';
import { Head } from './lib/head';

export async function render(path: string): Promise<RenderResult> {
	const stream = await renderToReadableStream(
		<StrictMode>
			<RouterProvider initialPath={path} routes={routes}>
				<Router />
			</RouterProvider>
		</StrictMode>,
	);

	// Wait for all Suspense boundaries to resolve
	await stream.allReady;

	const html = await streamToString(stream);

	// Render head tags using the same component as client
	const meta = getMetaForPath(path, routes);
	const headStream = await renderToReadableStream(
		<Head {...meta} url={path} server={true} />,
	);
	const head = await streamToString(headStream);

	return { html, head };
}
```

A few things happening here:

- **`renderToReadableStream`**: React 18+ streaming API. Returns a stream we can convert to a string.
- **`stream.allReady`**: Waits for all Suspense boundaries to resolve. Since we're pre-rendering, we want the complete HTML.
- **`initialPath`**: Tells the router which route to render (see [Part 2](/blog/building-portfolio-part-2-router)).
- **`Head` component**: The same component used on the client, rendered to HTML for SSG. The `server={true}` flag makes it render immediately instead of waiting for `useEffect`.

## Auto-Crawling

Most SSG frameworks require you to explicitly list every page. Next.js has `getStaticPaths`, Astro uses file-based routing with explicit content collections. I wanted something lazier.

The idea: start at `/`, render it, find all internal links, add them to a queue, repeat until there's nothing left to render.

```typescript
async function ssg() {
	const visited = new Set<string>();
	const queue: string[] = ['/'];
	const pages: { path: string; html: string }[] = [];

	while (queue.length > 0) {
		const path = queue.shift()!;

		if (visited.has(path)) continue;
		visited.add(path);

		console.log(`  -> Rendering ${path}`);

		const { html, head } = await render(path);

		// Inject into template, add preloads, etc.
		const pageHtml = buildFullPage(html, head, path);

		// Find all internal links
		const links = extractLinks(pageHtml);

		for (const link of links) {
			if (!visited.has(link)) {
				queue.push(link);
			}
		}

		pages.push({ path, html: pageHtml });
	}

	// Don't forget 404—it's not discoverable via links
	pages.push({ path: '/404', html: await render404() });

	// Write everything to disk
	for (const { path, html } of pages) {
		writeHtmlFile(path, html);
	}
}
```

The link extraction is simple regex:

```typescript
function extractLinks(html: string): string[] {
	const linkRegex = /href="(\/[^"#]*)"/g;
	const links: string[] = [];

	const ignoredExtensions = ['.css', '.js', '.svg', '.png' /* ... */];

	while ((match = linkRegex.exec(html)) !== null) {
		let path = match[1];

		// Skip assets
		if (ignoredExtensions.some((ext) => path.endsWith(ext))) continue;
		if (path.startsWith('/assets/')) continue;

		links.push(path);
	}

	return [...new Set(links)];
}
```

This approach has a nice property: if a page isn't linked from anywhere, it won't be generated. That's usually what you want—orphan pages shouldn't exist. The 404 page is the exception, so we render it explicitly.

## Module Preloading

This is where SSG pays dividends. Remember how every route is lazy-loaded ([Part 2](/blog/building-portfolio-part-2-router))? Without preloading, navigating to `/blog/some-post` would:

1. Load the page
2. Discover it needs the blog post chunk
3. Fetch the chunk
4. Render

With preloading, we tell the browser "you're going to need these files" before it asks:

```html
<link rel="modulepreload" href="/assets/+Page-ghi789.js" />
<link rel="modulepreload" href="/assets/some-post-xyz.js" />
```

The SSG script calculates preloads by walking the manifest's import graph:

```typescript
function getModulePreloads(
	path: string,
	manifest: Manifest,
	routeMappings: RouteMapping[],
): string[] {
	const preloads = new Set<string>();
	const route = findRouteSource(path, routeMappings);
	if (!route) return [];

	function collectImports(key: string, visited = new Set<string>()) {
		if (visited.has(key)) return;
		visited.add(key);

		const entry = manifest[key];
		if (!entry) return;

		// Add the file itself (except main entry)
		if (!entry.isEntry) {
			preloads.add(entry.file);
		}

		// Recursively collect imports
		if (entry.imports) {
			for (const imp of entry.imports) {
				collectImports(imp, visited);
			}
		}
	}

	collectImports(route.source);

	// Also preload content (MDX files)
	if (route.contentSource) {
		collectImports(route.contentSource);
	}

	return [...preloads];
}
```

Each page gets exactly the preloads it needs—no more, no less. The home page preloads its chunk. The blog post page preloads the post layout chunk plus the specific MDX content chunk.

## The HTML Template

The source `index.html` is a simple template that Vite uses by default:

```html
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<!--app-head-->
	</head>
	<body>
		<div id="root"><!--app-html--></div>
		<script type="module" src="/src/main.tsx"></script>
	</body>
</html>
```

The SSG script replaces the placeholders:

```typescript
const pageHtml = template
	.replace('<!--app-html-->', html)
	.replace('<!--app-head-->', `${head}\n\t${headTags}`)
	.replace(
		'<script type="module" src="/src/main.tsx"></script>',
		`<script type="module" src="/${entryScript}"></script>`,
	);
```

The dev script (`/src/main.tsx`) becomes the production entry from the manifest. Head tags include meta, OpenGraph, stylesheets, and module preloads.

## Output Structure

After SSG runs, the output looks like:

```
dist/static/
├── index.html              # /
├── 404.html                # Fallback for unknown routes
├── blog/
│   ├── index.html          # /blog
│   └── some-post/
│       └── index.html      # /blog/some-post
├── projects/
│   └── portfolio/
│       └── index.html      # /projects/portfolio
├── terminal/
│   └── index.html          # /terminal
└── assets/
    ├── index-[hash].js     # Main bundle
    ├── +Page-[hash].js     # Route chunks
    └── style-[hash].css    # Styles
```

Each route gets its own `index.html`. Cloudflare (and most hosts) serve `index.html` automatically for directory requests, so `/blog` serves `/blog/index.html`.

## Hydration

When the browser loads a pre-rendered page, React needs to "hydrate" it—attach event handlers to the existing HTML instead of re-rendering from scratch.

The client entry does this:

```tsx
// src/main.tsx
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(
	document.getElementById('root')!,
	<StrictMode>
		<RouterProvider routes={routes}>
			<Router />
		</RouterProvider>
	</StrictMode>,
);
```

`hydrateRoot` instead of `createRoot`. React walks the existing DOM, verifies it matches what it would render, and attaches handlers. If there's a mismatch, you get a hydration error—usually caused by the server and client rendering different content.

Common causes:

- Using `Date.now()` or `Math.random()` during render
- Reading browser-only APIs during SSR
- Router path mismatch between SSG and client

The router handles this by accepting `initialPath` during SSG and reading `window.location` during hydration—they should always match.

## Head Generation

Each page needs proper meta tags for SEO and social sharing. The typical approach is to have a string-based `generateHead()` function for SSG and a separate React component for client-side updates. But that means maintaining two implementations that need to stay in sync.

Instead, I use a single `Head` component for both:

```tsx
// src/lib/head/Head.tsx
export function Head({
	title,
	description,
	url,
	ogImage,
	keywords,
	type = 'website',
	server = false,
}: HeadProps) {
	const [isClient, setIsClient] = useState(server);

	useEffect(() => {
		clearExistingMetaTags();
		setIsClient(true);
	}, []);

	if (!isClient) {
		return null;
	}

	const fullUrl = `${BASE_URL}${url}`;
	// ...

	return (
		<>
			<title>{title}</title>
			<meta name="description" content={description} />
			<meta property="og:title" content={title} />
			<meta property="og:description" content={description} />
			{/* ... */}
		</>
	);
}
```

React 19 automatically hoists `<title>`, `<meta>`, and `<link>` tags to the document `<head>`. No portal required, no Helmet library. You render them inline and React handles the rest.

### Server vs Client Rendering

During SSG, the component renders with `server={true}`:

```tsx
// entry-server.tsx
const headStream = await renderToReadableStream(
	<Head {...meta} url={path} server={true} />,
);
```

This produces HTML that gets injected into each page's `<head>`. Standard SSG behavior.

On the client, the component needs to handle hydration carefully. If it rendered the same tags immediately, React would try to hydrate against the SSG-generated HTML—but those tags are in the `<head>`, not inside the React root. Hydration would fail or produce duplicates.

The solution is two-pass rendering:

1. **First pass**: Return `null`. React hydrates successfully because there's nothing to match.
2. **Second pass**: After `useEffect` runs, render the actual tags. React 19 hoists them to `<head>`.

The `useState(server)` initialization handles this. On the server, `server={true}` so it renders immediately. On the client, `server` defaults to `false`, so `isClient` starts as `false` and only becomes `true` after the effect runs.

### Cleaning Up SSG Tags

There's a catch. When navigating to a new page, the new route's `Head` component renders fresh meta tags. But the old page's SSG-generated tags are still sitting in the `<head>`. Now you have duplicates—two titles, two descriptions, two OG images.

Search engines might pick up the wrong one. Page weight increases. The canonical URL could be wrong.

The fix is manual cleanup before React adds new tags:

```typescript
function clearExistingMetaTags() {
	document.querySelector('title')?.remove();

	const metaNames = ['description', 'author', 'keywords', 'twitter:card' /* ... */];
	metaNames.forEach((name) => {
		document.querySelector(`meta[name="${name}"]`)?.remove();
	});

	const metaProperties = ['og:type', 'og:url', 'og:title' /* ... */];
	metaProperties.forEach((property) => {
		document.querySelector(`meta[property="${property}"]`)?.remove();
	});

	document.querySelector('link[rel="canonical"]')?.remove();
	document.querySelector('script[type="application/ld+json"]')?.remove();
}
```

This runs in the `useEffect` before `setIsClient(true)`. The SSG tags get removed, then React adds the new ones. Clean slate on every navigation.

Is this elegant? Not particularly. It's the kind of thing frameworks hide from you. But it's also about 30 lines of code, it works reliably, and I understand exactly what it does. That trade-off works for me.

The route's `meta` property (defined in `routes.ts`) provides the data. For dynamic routes like `/blog/:slug`, meta is a function that computes values from params.

## The Build Output

Running `pnpm build` produces:

```
Starting SSG build with auto-crawling...

  Scripts: assets/index-Dq3kM2xN.js
  Styles: assets/index-BYq1zK9P.css
  Routes discovered: 5
    - ^\/$ -> src/pages/+Page.tsx
    - ^\/blog$ -> src/pages/blog/+Page.tsx
    - ^\/blog\/([^/]+)$ -> src/pages/blog/[slug]/+Page.tsx (with content)
    - ^\/projects\/([^/]+)$ -> src/pages/project/[slug]/+Page.tsx (with content)
    - ^\/terminal$ -> src/pages/terminal/+Page.tsx

Crawling pages...

  -> Rendering /
  -> Rendering /blog
  -> Rendering /projects/portfolio
  -> Rendering /blog/building-portfolio-part-1-why
  -> Rendering /terminal
  -> Rendering /404

Generated 6 pages.

SSG build complete!
```

The crawler found everything by following links. No manual route configuration needed.

## What I'd Change for a Larger Site

This SSG implementation is tailored for a portfolio. For a larger site, I'd consider:

- **Incremental builds**: Only re-render pages whose content changed
- **Parallel rendering**: Render multiple pages concurrently (currently sequential)
- **Build caching**: Cache rendered HTML between builds
- **Sitemap generation**: Auto-generate sitemap.xml from crawled routes

None of these are hard—they're just not worth the complexity for a handful of pages.

## Alternatives I Considered

**Next.js**: The obvious choice. `getStaticProps` and `getStaticPaths` are well-designed. But I wanted to understand SSG at a lower level, and I didn't want to accept Next.js's opinions about everything else.

**Astro**: Great for content-heavy sites. The island architecture is clever. But I wanted a fully interactive React app, not islands of interactivity in a sea of static HTML.

**vite-plugin-ssr** (now Vike): Closest to what I built. If I were starting over, I might use it. But rolling my own taught me more about how SSG actually works.

## The Full Picture

The complete SSG system is about 350 lines across a few files:

- `scripts/ssg.ts` - Crawling, manifest parsing, preload calculation, HTML generation
- `src/entry-server.tsx` - React rendering entry point
- `src/lib/head/Head.tsx` - Unified head component for server and client

No special webpack loaders, no framework-specific data fetching conventions, no magic. Just Node.js reading a manifest, rendering React, and writing HTML files. The head management is the messiest part—cleaning up SSG tags on navigation isn't pretty—but it's all explicit and debuggable.

---
